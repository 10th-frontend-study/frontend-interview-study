# 시작하기 전에 잠깐 생각🫚해보기

### 🚀 Quiz.1

아래의 코드는 어떤 결과를 출력할까요

```jsx
console.log(text); // 1)

text = "Wonju Zzang!";
console.log(text); // 2)

var text;
```

- **Answer.1**
  ```jsx
  console.log(text); // 1번 답) Undefined 가 출력됨

  text = "Wonju Zzang!";
  console.log(text); // 2번 답) `Wonju Zzang!`이 출력됨

  var text;
  ```

<br/>

### 🚀 Quiz.2

그렇다면 아래의 코드는 어떤 결과를 출력할까요

```jsx
console.log(text);
let text;
```

- **Answer.2**
  ```jsx
  console.log(text); // ReferenceError: Cannot access uninitialized variable.
  let text;
  ```

<br/>

# 호이스팅이란?

![duli](../../resources/duli.png)

호이스팅이란 코드가 실행되기 전 변수선언 혹은 함수선언이 해당 스코프의 최상단으로 **끌어 올려진 것 같은 현상**을 말한다.

**자바스크립트 엔진**은 코드를 실행하기 전 실행 가능한 코드를 형상화하고 구분하는 과정*(*`**실행 컨텍스트를 위한 과정`)\*\*을 거친다.

- 잠만🙋🏻‍♀️ `**실행 컨텍스트**`가 뭐임?

  실행 컨텍스트는 `scope`, `hoisting`, `this`, `function`, `closure` 등의 동작원리를 담고 있는 **자바스크립트의 핵심원리**이다.

  다시 말해, 실행 컨텍스트 란 **코드에 제공할 환경 정보들을 모아놓은 객체**이다.

  실행 컨텍스트는 **코드들을 실행할 때 필요한 환경 정보** 들을 모아 객체를 구성하고, 이를 **콜 스택** 에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 **전체 코드의 환경과 순서를 보장**한다.

  어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행한다.

  - 😵‍💫 이게 무슨 소리지.. 싶으면 여기를 클릭하자
    https://heycoding.tistory.com/86

- 자바스크립트 엔진은 코드를 실행하기 전 실행 컨텍스트를 위한 과정에서 모든 선언(`var`, `let`, `const`, `function`, `class`)을 스코프에 등록한다.
- 코드 실행 전 이미 `변수선언 / 함수선언`이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나와도 오류 없이 동작한다.

> 따라서, `호이스팅`의 정확한 의미는 선언이 코드 실행 보다 먼저 메모리에 저장되는 과정으로 인한 현상을 말한다.

<br/>


# **변수 호이스팅**

> **부제: var, let, const 키워드**

자바스크립트의 모든 선언에는 호이스팅이 일어난다.

그런데 `let`, `const`, `class`를 이용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.

`var` 키워드로 선언된 변수와는 달리 `let` 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.

이전 [🚀 Quiz.2](https://www.notion.so/Quiz-2-aba9a8fea27a4235b7be2ffe62c8fcdc?pvs=21) 에서 `var`로 선언했을 때와 달리 `let`으로 선언했을 때 ReferenceError 가 발생한 상황과 동일한데,

이는 `let` 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 \*일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다. (자세한건 아래에서 설명함 ㄱㄷ)

<aside>
⚠️ **주의)** `호이스팅`의 의미는 **‘선언이 먼저 메모리에 저장되었다.’**는 것을 의미하기 때문에 
(즉, ‘선언이 끌어올려진다’는 의미이기 때문에) `모든 선언은 호이스팅이 일어난다`는 말은 참이 된다.

따라서 선언문 이전에 참조해서 에러를 발생시킨다고 호이스팅이 일어나지 않은 것은 아니라는 의미이다. 호이스팅은 `var` 키워드만 되는 것이 아님에 주의하자!

</aside>

<br/>

### 그렇다면 왜 참조 에러가 발생할까

그전에 정확히 짚고 갈 것은 선언이 끌어올려졌다는 표현이 의미하는 바는 다음과 같다.

> 선언이 코드 실행 전에 메모리에 저장되었다.

그런데 왜 참조 에러가 나는지 알려면 **‘변수가 생성되는 과정’**을 알 필요가 있다.

<br/>

## 변수가 태어나는 과정 살펴보기

> 변수(0세, 무직)

**변수는 아래 3단계에 걸쳐 태어난다.**

<br/>

### **1단계: 선언 단계(Declaration phase)**

변수를 `실행 컨텍스트`의 변수 객체에 등록한다.이 변수 객체는 스코프가 참조하는 대상이 된다.

### **2단계: 초기화 단계(Initialization phase)**

변수 객체에 등록된 변수를 위한 공간을 `메모리`에 확보한다.이 단계에서 변수는 `undefined`로 초기화 된다.

### **3단계: 할당 단계(Assignment phase)**

`undefined`로 초기화된 변수에 실제 값을 할당한다.

<br/>

## var과 let의 차이 (in 변수가 생성되는 과정)

### var

- `var`은 **선언 단계와 초기화 단계가 한 번에 이루어진다.**
  - 즉, 스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화한다.
- 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다.
- 다만 undefined를 반환한다.
- 이후 변수 할당문에 도달하면 비로소 값이 할당된다.

이 과정을 이해하고 [🚀 Quiz.1](https://www.notion.so/Quiz-1-4c64bc2092e94e8bbf1657965c885a70?pvs=21) 문제를 다시 보면 더 이해가 잘 될 거임

### let

- `let` 키워드로 선언된 변수는 **선언 단계와 초기화 단계가 분리되어 진행된다.**
  - 즉, 스코프에 변수를 등록(선언 단계)하지만 초기화 단계는 변수 선언문에 도달했을 때(코드 실행 후) 이뤄진다.
- 초기화 이전에 변수에 접근하려고 하면 참조 에러가 발생한다.
- 이는 아직 변수가 초기화되지 않았기 때문이다.
  - 즉, 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다.
- 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다.
- 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 `일시적 사각지대(Temporal Dead Zone; TDZ)`라고 부른다.

<br/>
<br/>

# 자 이제 알았으면

아까 퀴즈 코드를 다시 보자

### var의 경우

```jsx
// 호이스팅 때문에 선언이 끌어올려져서 오류 안남.
console.log(text); // (선언 + 초기화 된 상태) [출력결과]: Undefined

text = "Wonju Zzang!"; // (선언 + 초기화 + 할당 된 상태)
console.log(text); // [출력결과]: Wonju Zzang!

var text;
```

<br/>

### let의 경우

```jsx
// 호이스팅 때문에 선언이 끌어올려졌지만 초기화는 안된 상태를 참조했기 때문에 참조 에러가 발생함
// ReferenceError: Cannot access uninitialized variable.

console.log(text); // (선언만 된 상태, 초기화(메모리 공간 확보와 undefined로 초기화) 안되서 참조 불가능 -> 에러남)

let text; // 여기서 초기화 단계가 수행됨
```

변수가 생성되는 과정과 호이스팅을 다 알고 보니 와 출력 결과가 이리도 자연스러워 보일 수가 없다.

<br/>

### 보너스) const의 경우

```jsx
const text; // 에러남.
// 주의! 애초에 const 키워드로 재할당 불가능! 그래서 초기화 이런거 없음 선언과 동시에 할당해야함
```
